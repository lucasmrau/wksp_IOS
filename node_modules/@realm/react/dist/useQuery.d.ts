import Realm from "realm";
import { AnyRealmObject, RealmClassType } from "./helpers";
type QueryCallback<T> = (collection: Realm.Results<T>) => Realm.Results<T>;
type DependencyList = ReadonlyArray<unknown>;
export type QueryHookOptions<T> = {
    type: string;
    query?: QueryCallback<T>;
    keyPaths?: string | string[];
};
export type QueryHookClassBasedOptions<T> = {
    type: RealmClassType<T>;
    query?: QueryCallback<T>;
    keyPaths?: string | string[];
};
export type UseQueryHook = {
    <T>(options: QueryHookOptions<T>, deps?: DependencyList): Realm.Results<T & Realm.Object<T>>;
    <T extends AnyRealmObject>(options: QueryHookClassBasedOptions<T>, deps?: DependencyList): Realm.Results<T>;
    <T>(type: string): Realm.Results<T & Realm.Object<T>>;
    <T extends AnyRealmObject>(type: RealmClassType<T>): Realm.Results<T>;
    /** @deprecated To help the `react-hooks/exhaustive-deps` eslint rule detect missing dependencies, we've suggest passing a option object as the first argument */
    <T>(type: string, query?: QueryCallback<T>, deps?: DependencyList): Realm.Results<T & Realm.Object<T>>;
    /** @deprecated To help the `react-hooks/exhaustive-deps` eslint rule detect missing dependencies, we've suggest passing a option object as the first argument */
    <T extends AnyRealmObject>(type: RealmClassType<T>, query?: QueryCallback<T>, deps?: DependencyList): Realm.Results<T>;
};
/**
 * Generates the `useQuery` hook from a given `useRealm` hook.
 * @param useRealm - Hook that returns an open Realm instance
 * @returns useObject - Hook that is used to gain access to a {@link Realm.Collection}
 */
export declare function createUseQuery(useRealm: () => Realm): UseQueryHook;
export {};
//# sourceMappingURL=useQuery.d.ts.map