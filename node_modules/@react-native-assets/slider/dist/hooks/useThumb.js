"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const useEvent_1 = require("./useEvent");
const useRounding_1 = __importDefault(require("./useRounding"));
/** Handle the state of a thumb for a slider */
const useThumb = (props) => {
    const { step, value: propValue, slideOnTap, minimumValue, maximumValue, onValueChange } = props;
    const [value, setValue] = react_1.default.useState(propValue || minimumValue); // The value desired
    const round = (0, useRounding_1.default)({ step, minimumValue, maximumValue });
    // This block will group close call to setValue into one single update to greatly improve perfs
    const [updated, setUpdated] = react_1.default.useState(false);
    const nextValue = react_1.default.useRef(value);
    react_1.default.useEffect(() => {
        if (updated) {
            setUpdated(false);
            setValue(nextValue.current);
        }
    }, [updated]);
    /** Update the thumb value */
    const updateValue = (0, useEvent_1.useEvent)((newValue) => {
        const rounded = round(newValue);
        if (rounded !== nextValue.current)
            setUpdated(true);
        nextValue.current = rounded;
    });
    // Update the value on bounds change
    react_1.default.useEffect(() => {
        updateValue(nextValue.current);
    }, [step, minimumValue, maximumValue, updateValue]);
    // Update the value on propchange
    react_1.default.useEffect(() => {
        updateValue(propValue);
    }, [propValue, updateValue]);
    /** Call onValueChange when the user changed the value */
    const userUpdateValue = (0, useEvent_1.useEvent)((newValue) => {
        updateValue(newValue);
        onValueChange && onValueChange(nextValue.current);
    });
    /**
     * Indicates whether we accept to move to the specified position.
     * If the position is too far and slideOnTap is set, we don't accept sliding there
     **/
    const canMove = (0, useEvent_1.useEvent)((newValue) => {
        if (slideOnTap)
            return true;
        else
            return Math.abs(newValue - value) / ((maximumValue - minimumValue) || 1) < 0.1;
    });
    return { updateValue: userUpdateValue, canMove, value };
};
exports.default = useThumb;
