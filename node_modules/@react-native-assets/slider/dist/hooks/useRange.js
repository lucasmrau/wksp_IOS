"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const useEvent_1 = require("./useEvent");
const useThumb_1 = __importDefault(require("./useThumb"));
/** Handle the state of a range slider */
const useRange = ({ step, range: propValue, minimumRange, minimumValue, maximumValue, slideOnTap, onValueChange, crossingAllowed }) => {
    const [range, setRange] = react_1.default.useState(propValue);
    const [minProp, maxProp] = propValue;
    const updateRange = (0, useEvent_1.useEvent)((rangeUpdate, fireEvent) => {
        setRange(oldRange => {
            const newRange = typeof rangeUpdate === 'function' ? rangeUpdate(oldRange) : rangeUpdate;
            // If no change, we return the previous object to avoir rerenders
            if (oldRange[0] === newRange[0] && oldRange[1] === newRange[1])
                return oldRange;
            // We call onValueChange as soon as the setState is over
            if (fireEvent && onValueChange)
                setTimeout(() => onValueChange(newRange), 0);
            return newRange;
        });
    });
    const userUpdateRange = (0, useEvent_1.useEvent)((newRange) => updateRange(newRange, true));
    // Update the value on bounds or prop change
    react_1.default.useEffect(() => {
        updateRange(propValue);
    }, [step, minimumValue, maximumValue, updateRange, propValue]);
    const updateMin = (0, useEvent_1.useEvent)((newMin) => userUpdateRange(([, oldMax]) => [newMin, oldMax]));
    const updateMax = (0, useEvent_1.useEvent)((newMax) => userUpdateRange(([oldMin]) => [oldMin, newMax]));
    // Min value thumb
    const { updateValue: updateMinValue, canMove: canMoveMin } = (0, useThumb_1.default)({
        minimumValue,
        maximumValue: range[1] - (crossingAllowed ? 0 : minimumRange),
        value: minProp,
        step,
        slideOnTap,
        onValueChange: updateMin
    });
    // Max value thumb
    const { updateValue: updateMaxValue, canMove: canMoveMax } = (0, useThumb_1.default)({
        minimumValue: range[0] + (crossingAllowed ? 0 : minimumRange),
        maximumValue,
        value: maxProp,
        step,
        slideOnTap,
        onValueChange: updateMax
    });
    const currentThumb = react_1.default.useRef();
    // Method to update the lower or higher bound according to which one is the closest
    const updateClosestValue = (0, useEvent_1.useEvent)((value, state) => {
        const [minValue, maxValue] = range;
        let isMinClosest = false;
        // When moving a thumb, we don't want to let it cross the other thumb
        if (currentThumb.current && !crossingAllowed)
            isMinClosest = currentThumb.current === 'min';
        else if (!currentThumb.current)
            isMinClosest = Math.abs(value - minValue) < Math.abs(value - maxValue);
        // if the current thumb is the min, we keep it as long as it's below the max
        else if (currentThumb.current === 'min')
            isMinClosest = value <= maxValue;
        // Otherwise, if we hold the max thumb, we switch only if the value is below the min
        else
            isMinClosest = value < minValue;
        // We update the state accordingly
        isMinClosest ? updateMinValue(value) : updateMaxValue(value);
        if (state === 'release')
            currentThumb.current = undefined; // We release the thumb
        else
            currentThumb.current = isMinClosest ? 'min' : 'max'; // We set the thumb being currently moved
        return isMinClosest ? [value, maxValue] : [minValue, value];
    });
    const canMove = (0, useEvent_1.useEvent)((value) => {
        return canMoveMax(value) || canMoveMin(value);
    });
    return { updateMinValue, updateMaxValue, updateClosestValue, canMove, range };
};
exports.default = useRange;
